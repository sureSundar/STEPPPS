#!/bin/bash
# TernaryBit OS - Universal Build Script
# Produces the canonical bootloader â†’ kernel â†’ shell image
# ðŸ•‰ï¸ Swamiye Saranam Aiyappa ðŸ•‰ï¸

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TBOS_ROOT="$SCRIPT_DIR"
BUILD_DIR="$TBOS_ROOT/build"
BOOT_DIR="$TBOS_ROOT/boot"
TOOLS_DIR="$TBOS_ROOT/tools"

IMAGE_NAME_DEFAULT="tbos_universal.img"
OUTPUT_IMG="$BUILD_DIR/$IMAGE_NAME_DEFAULT"
KERNEL_SOURCE_DEFAULT="kernel/kernel_main.c"
KERNEL_SOURCE="$KERNEL_SOURCE_DEFAULT"
PROFILE="universal"
PROFILE_DIR="$TBOS_ROOT/config"
GENERATED_INCLUDE_DIR="$BUILD_DIR/generated"
LEGACY_IMAGE="$BUILD_DIR/tbos_bare_metal.img"
HOSTED_DIR="$TBOS_ROOT/hosted"
HOSTED_BIN="$TBOS_ROOT/src/shell/universal/tbos_shell"

declare -A CONFIG
CONFIG_KEYS=(SHELL FS VFS KEYBOARD INTERRUPTS)

normalize_value() {
    local raw="$1"
    local fallback="$2"
    local lower="${raw,,}"
    case "$lower" in
        y|yes|true|1) echo "y" ;;
        n|no|false|0) echo "n" ;;
        *) echo "$fallback" ;;
    esac
}

reset_config() {
    CONFIG=()
}

load_profile() {
    reset_config
    local profile_file="$PROFILE_DIR/profile_${PROFILE}.conf"
    if [[ ! -f "$profile_file" ]]; then
        echo "error: profile '$PROFILE' not found ($profile_file)" >&2
        exit 1
    fi

    # shellcheck disable=SC1090
    source "$profile_file"

    local shell_val
    local fs_val
    local vfs_val
    local keyboard_val
    local irq_val

    shell_val=$(normalize_value "${CONFIG_SHELL:-}" "y")
    fs_val=$(normalize_value "${CONFIG_FS:-}" "y")
    vfs_val=$(normalize_value "${CONFIG_VFS:-}" "$fs_val")
    keyboard_val=$(normalize_value "${CONFIG_KEYBOARD:-}" "y")
    irq_val=$(normalize_value "${CONFIG_INTERRUPTS:-}" "y")

    CONFIG["SHELL"]="$shell_val"
    CONFIG["FS"]="$fs_val"
    CONFIG["VFS"]="$vfs_val"
    CONFIG["KEYBOARD"]="$keyboard_val"
    CONFIG["INTERRUPTS"]="$irq_val"
}

config_enabled() {
    local key="$1"
    [[ "${CONFIG[$key]:-y}" == "y" ]]
}

ensure_generated_headers() {
    mkdir -p "$GENERATED_INCLUDE_DIR/tbos"
}

generate_config_header() {
    ensure_generated_headers
    local header="$GENERATED_INCLUDE_DIR/tbos/config.h"
    {
        echo "#pragma once"
        echo "/* Auto-generated by build_universal.sh */"
        echo "#define CONFIG_PROFILE \"$PROFILE\""
        for key in "${CONFIG_KEYS[@]}"; do
            if config_enabled "$key"; then
                echo "#define CONFIG_${key} 1"
            else
                echo "#define CONFIG_${key} 0"
            fi
        done
    } > "$header"
}

log_step() {
    echo ""
    echo "==> $1"
}

show_usage() {
    cat <<EOF
Usage: $(basename "$0") [options]

Options:
  --output <path>   Set output disk image (default: build/$IMAGE_NAME_DEFAULT)
  --kernel <path>   Override kernel C source (default: $KERNEL_SOURCE_DEFAULT)
  --profile <name>  Select build profile (config/profile_<name>.conf) (default: $PROFILE)
  -h, --help        Show this help
EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --output)
                shift
                [[ $# -gt 0 ]] || { echo "error: --output requires a value" >&2; exit 1; }
                OUTPUT_IMG="$1"
                shift
                ;;
            --kernel)
                shift
                [[ $# -gt 0 ]] || { echo "error: --kernel requires a value" >&2; exit 1; }
                KERNEL_SOURCE="$1"
                shift
                ;;
            --profile)
                shift
                [[ $# -gt 0 ]] || { echo "error: --profile requires a value" >&2; exit 1; }
                PROFILE="$1"
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                echo "error: unknown option: $1" >&2
                show_usage >&2
                exit 1
                ;;
        esac
    done
}

handle_host_profile() {
    log_step "Hosted profile detected"
    if [[ ! -d "$HOSTED_DIR" ]]; then
        echo "error: hosted tooling not found" >&2
        exit 1
    fi
    "$HOSTED_DIR/build_hosted.sh"
    if [[ -x "$HOSTED_DIR/test_hosted.sh" ]]; then
        "$HOSTED_DIR/test_hosted.sh"
    fi
    echo ""
    echo "Hosted binary available at: $HOSTED_BIN"
    echo "Use 'make hosted' or run the binary directly for interactive sessions."
    exit 0
}

ensure_build_dir() {
    mkdir -p "$BUILD_DIR"
}

build_objects=()

compile_asm() {
    local src="$1"
    local out="$2"
    nasm -f elf64 "$src" -o "$out"
    build_objects+=("$out")
}

compile_c() {
    local src="$1"
    local absolute="$src"
    if [[ "$absolute" != /* ]]; then
        absolute="$TBOS_ROOT/$absolute"
    fi

    local rel="${absolute#$TBOS_ROOT/}"
    local obj_name="${rel//\//_}"
    obj_name="${obj_name%.c}.o"
    local out="$BUILD_DIR/$obj_name"
    local include_flags=(-I"$GENERATED_INCLUDE_DIR" -I"$TBOS_ROOT/include")

    # Compile as 64-bit
    # Use -O0 for kernel_main.c to prevent loop optimization issues with VGA writes
    local opt_level="-O2"
    if [[ "$rel" == "kernel/kernel_main.c" ]]; then
        opt_level="-O0"
    fi
    echo "    [$rel] Compiling 64-bit with $opt_level"

    gcc -m64 -mcmodel=kernel -mno-red-zone \
        -ffreestanding -fno-builtin -fno-stack-protector -fno-pic -fno-pie \
        -fcf-protection=none \
        -nostdlib -Wall -Wextra $opt_level \
        "${include_flags[@]}" \
        -c "$absolute" -o "$out"

    build_objects+=("$out")
}

assemble_bootloader_stage1() {
    local stage2_sectors="$1"
    nasm -I "$BOOT_DIR" -f bin \
        -D STAGE2_SECTOR_COUNT="$stage2_sectors" \
        "$BOOT_DIR/tbos_sacred.asm" -o "$BUILD_DIR/boot.bin"

    local size
    size=$(stat -c%s "$BUILD_DIR/boot.bin")
    if [[ "$size" -ne 512 ]]; then
        echo "error: boot sector must be exactly 512 bytes (got $size)" >&2
        exit 1
    fi
}

assemble_bootloader_stage2() {
    local kernel_start="$1"
    local kernel_sectors="$2"

    # Use long mode bootloader for 64-bit support
    nasm -I "$BOOT_DIR" -f bin \
        -D KERNEL_START_SECTOR="$kernel_start" \
        -D KERNEL_SECTORS="$kernel_sectors" \
        "$BOOT_DIR/stage2_long_mode.asm" -o "$BUILD_DIR/stage2.bin"
}

link_kernel() {
    ld -m elf_x86_64 \
        -T "$TBOS_ROOT/kernel/linker_sacred.ld" \
        -o "$BUILD_DIR/kernel.elf" \
        "${build_objects[@]}"
}

emit_kernel_binary() {
    objcopy -O binary "$BUILD_DIR/kernel.elf" "$BUILD_DIR/kernel.bin"
    dd if="$BUILD_DIR/kernel.bin" of="$BUILD_DIR/kernel_padded.bin" \
        bs=512 conv=sync status=none
}

tbpx_roundtrip() {
    local tool="$TOOLS_DIR/tbpx_codec.py"
    [[ -f "$tool" ]] || { echo "    Skipping TBPX step (tools/tbpx_codec.py not found)"; return; }

    if python3 -c "import PIL" >/dev/null 2>&1; then
        format="png"
    else
        format="ppm"
    fi

    local encoded="$BUILD_DIR/kernel_tbpx.$format"
    python3 "$tool" encode "$BUILD_DIR/kernel.bin" "$encoded" \
        --width 256 --repeat-header --format "$format" >/dev/null
    python3 "$tool" decode "$encoded" "$BUILD_DIR/kernel_from_tbpx.bin" >/dev/null

    if cmp -s "$BUILD_DIR/kernel.bin" "$BUILD_DIR/kernel_from_tbpx.bin"; then
        echo "    TBPX roundtrip: OK (kernel.bin -> $format -> bin)"
    else
        echo "error: TBPX roundtrip failed (kernel mismatch after decode)" >&2
        exit 1
    fi
}

create_disk_image() {
    local stage2_sectors="$1"
    local kernel_start="$2"

    local img_size=$((10 * 1024 * 1024))  # 10 MiB
    truncate -s "$img_size" "$OUTPUT_IMG"

    dd if="$BUILD_DIR/boot.bin" of="$OUTPUT_IMG" conv=notrunc status=none
    dd if="$BUILD_DIR/stage2.bin" of="$OUTPUT_IMG" seek=1 conv=notrunc status=none
    dd if="$BUILD_DIR/kernel_padded.bin" of="$OUTPUT_IMG" seek="$kernel_start" \
        conv=notrunc status=none

    if [[ "$OUTPUT_IMG" != "$LEGACY_IMAGE" ]]; then
        cp "$OUTPUT_IMG" "$LEGACY_IMAGE"
    fi
}

report_summary() {
    local stage2_size kernel_size img_bytes
    stage2_size=$(stat -c%s "$BUILD_DIR/stage2.bin")
    kernel_size=$(stat -c%s "$BUILD_DIR/kernel.bin")
    img_bytes=$(stat -c%s "$OUTPUT_IMG")

    echo ""
    echo "Build complete!"
    echo "  Profile     : $PROFILE"
    echo "  Features     : shell=${CONFIG[SHELL]} fs=${CONFIG[FS]} vfs=${CONFIG[VFS]} keyboard=${CONFIG[KEYBOARD]} interrupts=${CONFIG[INTERRUPTS]}"
    echo "  Stage 1      : 512 bytes"
    echo "  Stage 2      : $stage2_size bytes"
    echo "  Kernel       : $kernel_size bytes"
    echo "  Disk image   : $img_bytes bytes ($OUTPUT_IMG)"
    if [[ "$OUTPUT_IMG" != "$LEGACY_IMAGE" ]]; then
        echo "  Legacy alias : $LEGACY_IMAGE"
    fi
    echo ""
    echo "Run with:"
    echo "  qemu-system-x86_64 -drive file=$OUTPUT_IMG,format=raw -m 512 -serial stdio"
    echo ""
}

main() {
    parse_args "$@"
    ensure_build_dir
load_profile

if [[ "$PROFILE" == "host" ]]; then
    handle_host_profile
fi
    generate_config_header

    echo "======================================="
    echo " Building TernaryBit OS (Universal) "
    echo "======================================="
    echo "Profile       : $PROFILE"

    log_step "Compiling kernel and drivers"

    build_objects=()
    compile_asm "$TBOS_ROOT/kernel/kernel_sacred.asm" "$BUILD_DIR/kernel_entry.o"
    if config_enabled "INTERRUPTS"; then
        compile_asm "$TBOS_ROOT/kernel/isr.asm" "$BUILD_DIR/isr.o"
    else
        echo "    [skip] Interrupt stubs disabled by profile"
    fi

    compile_c "kernel/hal_baremetal.c"
    compile_c "kernel/tbds.c"
    compile_c "$KERNEL_SOURCE"
    if config_enabled "INTERRUPTS"; then
        compile_c "kernel/interrupt.c"
    else
        echo "    [skip] Interrupt controller disabled by profile"
    fi
    compile_c "kernel/libc.c"
    if config_enabled "FS"; then
        compile_c "kernel/fs/ramfs.c"
        compile_c "kernel/fs/vfs.c"
        compile_c "kernel/fs/ucfs_driver.c"
        compile_c "src/core/filesystem/blockdev.c"
        compile_c "src/core/filesystem/ucfs_codec.c"
        compile_c "src/core/filesystem/ucfs_overlay.c"
        compile_c "src/core/filesystem/ucfs_config.c"
    else
        echo "    [skip] VFS/RAMFS disabled by profile"
    fi
    if config_enabled "KEYBOARD"; then
        if config_enabled "INTERRUPTS"; then
            compile_c "drivers/keyboard/keyboard.c"
        else
            echo "    [skip] Keyboard driver requires CONFIG_INTERRUPTS"
        fi
    else
        echo "    [skip] Keyboard driver disabled by profile"
    fi
    if config_enabled "SHELL"; then
        compile_c "shell/shell.c"
    else
        echo "    [skip] Interactive shell disabled by profile"
    fi

    log_step "Linking kernel"
    link_kernel
    emit_kernel_binary

    kernel_size=$(stat -c%s "$BUILD_DIR/kernel_padded.bin")
    kernel_sectors=$((kernel_size / 512))
    echo "    Kernel size    : $kernel_size bytes"
    echo "    Kernel sectors : $kernel_sectors"

    log_step "Assembling bootloader stages"
    local placeholder_stage2=8
    local placeholder_start=$((1 + placeholder_stage2))
    assemble_bootloader_stage2 "$placeholder_start" "$kernel_sectors"

    stage2_size=$(stat -c%s "$BUILD_DIR/stage2.bin")
    stage2_sectors=$(((stage2_size + 511) / 512))
    kernel_start=10  # Must match KERNEL_START_SECTOR in stage2_protected.asm

    assemble_bootloader_stage2 "$kernel_start" "$kernel_sectors"
    stage2_size=$(stat -c%s "$BUILD_DIR/stage2.bin")
    local stage2_sectors_verified=$(((stage2_size + 511) / 512))
    if [[ "$stage2_sectors_verified" -ne "$stage2_sectors" ]]; then
        echo "error: stage2 size mismatch after reassembly (expected $stage2_sectors sectors, got $stage2_sectors_verified)" >&2
        exit 1
    fi
    stage2_sectors="$stage2_sectors_verified"
    assemble_bootloader_stage1 "$stage2_sectors"

    log_step "Creating bootable disk image"
    create_disk_image "$stage2_sectors" "$kernel_start"

    log_step "Pixelizing kernel via TBPX (optional)"
    tbpx_roundtrip

    report_summary
}

main "$@"
