<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STEPPPS - Single Pixel Intelligence Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin: 0;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .config-panel {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 14px;
        }

        .button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 10px 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .test-area {
            display: flex;
            gap: 30px;
            margin-top: 30px;
        }

        .pixel-canvas {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            flex: 1;
        }

        .pixel-canvas h3 {
            color: #333;
            text-align: center;
            margin-top: 0;
        }

        #canvas {
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }

        .intelligence-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            flex: 1;
            max-height: 600px;
            overflow-y: auto;
        }

        .intelligence-panel h3 {
            margin-top: 0;
            color: #4ecdc4;
        }

        .pixel-data {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .ai-response {
            background: rgba(76, 175, 80, 0.2);
            border-left: 4px solid #4CAF50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 10px 10px 0;
        }

        .loading {
            color: #ffc107;
            font-style: italic;
        }

        .error {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† STEPPPS Protocol</h1>
            <p>Single Pixel Intelligence Test - Every Pixel Becomes an AI Agent</p>
        </div>

        <div class="config-panel">
            <h3>üîß LLM Configuration</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 15px; align-items: end;">
                <div class="input-group">
                    <label>Provider</label>
                    <select id="llmProvider" onchange="updateLLMConfig()">
                        <option value="claude">Claude (Anthropic)</option>
                        <option value="ollama">Ollama (Local)</option>
                        <option value="openai">OpenAI GPT</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Model</label>
                    <input type="text" id="llmModel" value="claude-3-sonnet-20240229" placeholder="Model name">
                </div>
                <div class="input-group">
                    <label>API Key</label>
                    <input type="password" id="apiKey" placeholder="Enter your API key">
                </div>
                <div>
                    <button class="button" onclick="testConnection()">üß™ Test</button>
                </div>
            </div>
            <div id="connectionStatus"></div>
        </div>

        <div class="stats">
            <div class="stat-box">
                <div class="stat-number" id="pixelCount">0</div>
                <div class="stat-label">Intelligent Pixels</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="aiInteractions">0</div>
                <div class="stat-label">AI Interactions</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="avgResponseTime">0ms</div>
                <div class="stat-label">Avg Response Time</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="intelligenceLevel">0%</div>
                <div class="stat-label">Intelligence Level</div>
            </div>
        </div>

        <div class="test-area">
            <div class="pixel-canvas">
                <h3>üé® Interactive Canvas - Click Any Pixel</h3>
                <canvas id="canvas" width="400" height="300"></canvas>
                <div style="text-align: center; margin-top: 15px;">
                    <button class="button" onclick="loadSampleImage()">üñºÔ∏è Load Sample</button>
                    <button class="button" onclick="clearCanvas()">üßπ Clear</button>
                    <button class="button" onclick="analyzeRandomPixels()">üé≤ Analyze Random</button>
                </div>
            </div>

            <div class="intelligence-panel">
                <h3>üß† Pixel Intelligence Log</h3>
                <div id="intelligenceLog"></div>
            </div>
        </div>
    </div>

    <script>
        // STEPPPS Framework Core
        class STEPPPSPixel {
            constructor(x, y, canvas) {
                this.space = {
                    coordinates: [x, y],
                    canvas_size: [canvas.width, canvas.height],
                    region: this.determineRegion(x, y, canvas),
                    neighbors: this.getNeighborCoordinates(x, y, canvas)
                };

                this.time = {
                    created_at: new Date().toISOString(),
                    updated_at: new Date().toISOString(),
                    interaction_count: 0,
                    last_touched: null
                };

                this.event = {
                    type: 'creation',
                    history: [],
                    context: 'user_interaction'
                };

                this.psychology = {
                    user_intent: 'exploration',
                    engagement_level: 0.5,
                    attention_weight: 0.1,
                    emotional_context: 'curious'
                };

                this.pixel = {
                    color: this.getPixelColor(x, y, canvas),
                    rgba: [0, 0, 0, 0],
                    luminance: 0,
                    saturation: 0
                };

                this.prompt = {
                    current: this.generateContextualPrompt(),
                    history: [],
                    ai_responses: []
                };

                this.script = {
                    local_hooks: [],
                    behaviors: ['highlight_on_hover', 'ai_analysis_on_click'],
                    execution_queue: []
                };

                this.updatePixelProperties(x, y, canvas);
            }

            determineRegion(x, y, canvas) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                if (y < centerY / 2) return 'top';
                if (y > centerY * 1.5) return 'bottom';
                if (x < centerX / 2) return 'left';
                if (x > centerX * 1.5) return 'right';
                return 'center';
            }

            getNeighborCoordinates(x, y, canvas) {
                const neighbors = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx, ny = y + dy;
                        if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height) {
                            neighbors.push([nx, ny]);
                        }
                    }
                }
                return neighbors;
            }

            getPixelColor(x, y, canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(x, y, 1, 1);
                const [r, g, b, a] = imageData.data;
                this.pixel.rgba = [r, g, b, a];
                this.pixel.luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                this.pixel.saturation = this.calculateSaturation(r, g, b);
                return `rgba(${r}, ${g}, ${b}, ${a/255})`;
            }

            calculateSaturation(r, g, b) {
                const max = Math.max(r, g, b) / 255;
                const min = Math.min(r, g, b) / 255;
                return max === 0 ? 0 : (max - min) / max;
            }

            updatePixelProperties(x, y, canvas) {
                this.pixel.color = this.getPixelColor(x, y, canvas);
                this.time.updated_at = new Date().toISOString();
            }

            generateContextualPrompt() {
                return `STEPPPS PIXEL ANALYSIS REQUEST:

PIXEL CONTEXT:
- Coordinates: (${this.space.coordinates[0]}, ${this.space.coordinates[1]})
- Canvas Region: ${this.space.region}
- Color: ${this.pixel.color} (RGBA: ${this.pixel.rgba.join(', ')})
- Luminance: ${(this.pixel.luminance * 100).toFixed(1)}%
- Saturation: ${(this.pixel.saturation * 100).toFixed(1)}%
- Canvas Size: ${this.space.canvas_size[0]}x${this.space.canvas_size[1]}

USER CONTEXT:
- Intent: ${this.psychology.user_intent}
- Engagement: ${this.psychology.engagement_level}
- Emotional State: ${this.psychology.emotional_context}
- Interaction Count: ${this.time.interaction_count}

ANALYSIS REQUEST:
Please analyze this pixel's role, suggest what it might represent in the image, describe its visual characteristics, and provide insights about its relationship to surrounding pixels. Be creative and contextual in your analysis.`;
            }

            async getAIResponse() {
                const config = getLLMConfig();
                if (!config.apiKey && config.provider !== 'ollama') {
                    throw new Error('API key required for ' + config.provider);
                }

                const prompt = this.generateContextualPrompt();
                this.prompt.history.push(prompt);

                try {
                    const response = await callLLM(config, prompt);
                    this.prompt.ai_responses.push({
                        timestamp: new Date().toISOString(),
                        response: response,
                        tokens: response.length
                    });

                    // Update psychology based on AI response
                    this.psychology.engagement_level = Math.min(1.0, this.psychology.engagement_level + 0.1);
                    this.time.interaction_count++;

                    return response;
                } catch (error) {
                    throw error;
                }
            }

            toJSON() {
                return {
                    space: this.space,
                    time: this.time,
                    event: this.event,
                    psychology: this.psychology,
                    pixel: this.pixel,
                    prompt: this.prompt,
                    script: this.script
                };
            }
        }

        // Global State
        let intelligentPixels = new Map();
        let totalInteractions = 0;
        let responseTimes = [];
        let canvas, ctx;

        // Initialize Canvas
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');

            // Add click handler
            canvas.addEventListener('click', handlePixelClick);

            // Draw initial gradient
            loadSampleImage();

            updateStats();
        });

        function updateLLMConfig() {
            const provider = document.getElementById('llmProvider').value;
            const modelField = document.getElementById('llmModel');

            const configs = {
                claude: 'claude-3-sonnet-20240229',
                ollama: 'llama3.2:latest',
                openai: 'gpt-3.5-turbo'
            };

            modelField.value = configs[provider];
        }

        function getLLMConfig() {
            return {
                provider: document.getElementById('llmProvider').value,
                model: document.getElementById('llmModel').value,
                apiKey: document.getElementById('apiKey').value.trim()
            };
        }

        async function testConnection() {
            const status = document.getElementById('connectionStatus');
            const config = getLLMConfig();

            status.innerHTML = '<div class="loading">üîÑ Testing connection...</div>';

            try {
                const response = await callLLM(config, 'Hello! This is a test connection. Please respond with a simple greeting.');
                status.innerHTML = '<div class="success">‚úÖ Connection successful! Response: ' + response.substring(0, 100) + '...</div>';
            } catch (error) {
                status.innerHTML = '<div class="error">‚ùå Connection failed: ' + error.message + '</div>';
            }
        }

        async function callLLM(config, prompt) {
            const startTime = performance.now();

            try {
                let response;

                switch (config.provider) {
                    case 'claude':
                        response = await callClaude(config, prompt);
                        break;
                    case 'ollama':
                        response = await callOllama(config, prompt);
                        break;
                    case 'openai':
                        response = await callOpenAI(config, prompt);
                        break;
                    default:
                        throw new Error('Unknown provider: ' + config.provider);
                }

                const endTime = performance.now();
                responseTimes.push(endTime - startTime);

                return response;
            } catch (error) {
                const endTime = performance.now();
                responseTimes.push(endTime - startTime);
                throw error;
            }
        }

        async function callClaude(config, prompt) {
            // Clean API key aggressively
            const cleanKey = config.apiKey
                .replace(/[^\x20-\x7E]/g, '') // Remove non-ASCII
                .replace(/[^a-zA-Z0-9\-_]/g, '') // Only allow alphanumeric, hyphens, underscores
                .trim();

            if (!cleanKey.startsWith('sk-ant-')) {
                throw new Error('Invalid Claude API key format. Must start with sk-ant-');
            }

            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': cleanKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: config.model,
                    max_tokens: 300,
                    messages: [{
                        role: 'user',
                        content: prompt
                    }]
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Claude API error (${response.status}): ${errorText}`);
            }

            const data = await response.json();
            return data.content[0].text;
        }

        async function callOllama(config, prompt) {
            const response = await fetch('http://localhost:11434/api/generate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: config.model,
                    prompt: prompt,
                    stream: false
                })
            });

            if (!response.ok) {
                throw new Error(`Ollama error: ${response.statusText}. Make sure Ollama is running locally.`);
            }

            const data = await response.json();
            return data.response;
        }

        async function callOpenAI(config, prompt) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${config.apiKey}`
                },
                body: JSON.stringify({
                    model: config.model,
                    messages: [{
                        role: 'user',
                        content: prompt
                    }],
                    max_tokens: 300
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`OpenAI API error: ${errorText}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        }

        async function handlePixelClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor(event.clientX - rect.left);
            const y = Math.floor(event.clientY - rect.top);

            // Create intelligent pixel
            const pixel = new STEPPPSPixel(x, y, canvas);
            intelligentPixels.set(`${x},${y}`, pixel);

            // Visual feedback
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Log pixel creation
            logIntelligence(`üéØ Created intelligent pixel at (${x}, ${y})`);
            logIntelligence(`üìä STEPPPS Data: Color=${pixel.pixel.color}, Region=${pixel.space.region}, Luminance=${(pixel.pixel.luminance*100).toFixed(1)}%`);

            // Get AI analysis
            try {
                logIntelligence(`üß† Requesting AI analysis for pixel (${x}, ${y})...`);
                const aiResponse = await pixel.getAIResponse();
                logIntelligence(`üéâ AI Response for pixel (${x}, ${y}): ${aiResponse}`);
                totalInteractions++;
            } catch (error) {
                logIntelligence(`‚ùå AI Analysis failed for pixel (${x}, ${y}): ${error.message}`);
            }

            updateStats();
        }

        function loadSampleImage() {
            // Create a colorful gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#ff6b6b');
            gradient.addColorStop(0.25, '#4ecdc4');
            gradient.addColorStop(0.5, '#45b7d1');
            gradient.addColorStop(0.75, '#96ceb4');
            gradient.addColorStop(1, '#feca57');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add some shapes for visual interest
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(100, 100, 30, 0, 2 * Math.PI);
            ctx.fill();

            ctx.fillStyle = '#000000';
            ctx.fillRect(200, 150, 80, 50);

            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.moveTo(320, 80);
            ctx.lineTo(350, 130);
            ctx.lineTo(290, 130);
            ctx.closePath();
            ctx.fill();

            logIntelligence('üñºÔ∏è Sample image loaded with gradient background and shapes');
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            intelligentPixels.clear();
            totalInteractions = 0;
            responseTimes = [];

            document.getElementById('intelligenceLog').innerHTML = '';
            logIntelligence('üßπ Canvas cleared and pixel intelligence reset');
            updateStats();
        }

        async function analyzeRandomPixels() {
            const numPixels = 5;
            logIntelligence(`üé≤ Analyzing ${numPixels} random pixels...`);

            for (let i = 0; i < numPixels; i++) {
                const x = Math.floor(Math.random() * canvas.width);
                const y = Math.floor(Math.random() * canvas.height);

                // Simulate click at random position
                const event = { clientX: x, clientY: y };
                setTimeout(() => {
                    const rect = canvas.getBoundingClientRect();
                    const clickEvent = {
                        clientX: rect.left + x,
                        clientY: rect.top + y
                    };
                    handlePixelClick(clickEvent);
                }, i * 1000); // Stagger the analyses
            }
        }

        function logIntelligence(message) {
            const log = document.getElementById('intelligenceLog');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'pixel-data';
            entry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function updateStats() {
            document.getElementById('pixelCount').textContent = intelligentPixels.size;
            document.getElementById('aiInteractions').textContent = totalInteractions;

            const avgTime = responseTimes.length > 0
                ? Math.round(responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length)
                : 0;
            document.getElementById('avgResponseTime').textContent = avgTime + 'ms';

            const intelligence = intelligentPixels.size > 0
                ? Math.round((totalInteractions / intelligentPixels.size) * 100)
                : 0;
            document.getElementById('intelligenceLevel').textContent = intelligence + '%';
        }
    </script>
</body>
</html>